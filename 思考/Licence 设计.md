# Licence 设计

## 1. 设计要求

1. 需要满足微服务架构
2. 部署方案需支持多种多样，jar、docker容器
3. 对于开发人员也具有一定的防破解能力（提供9成源代码情况下）
4. 支持多种认证方式（在线、离线）

> 在JAVA的世界来说，由于字节码的缘故，反编译变的轻而易举。非常容易就可以破解到。
>

## 2. 理想方案

　　由于JAVA的特性来说，要做到高难度防破解，需要从最底层出发。

1. 修改编译Java虚拟机，提供C语言级别的类加载器。
2. 大部分核心代码进行加密，只能使用特定的虚拟机才能解密加载
3. 以上是运行环境，开发环境需要提供特定IDE。特定IDE才能解密核心代码进行调用。或者提供运行时动态解码相关引用类。

> 做到以上也只能加大破解难度，如果有大佬汇编特别牛逼。那这样的方案不值一提。~_~
>

## 3. 简单方案

　　本方案说的简单一点就是让在大海一样的代码里面难以找到相关控制的代码。另外在调试模式下也难以跟踪，只能找到特点的点才能彻底解决。（小聪明版本）

　　**1）如何隐藏代码**

* 相关的控制代码做成独立的jar包，此包名建议采用开源框架名称。极具迷惑性。
* 打印调试Licence验证失败错误信息采用动态类，比如采用ASM等字节码技术。
* 编译代码进行混淆处理。
* 触发入口可以采用SPI、spring.factories、静态代码块（随便在一个地方Class.forName）
* 尽量不使用第三方类库，容易被猜到。如果一定用到，把类库源代码复制到jar包中且需要修改包路径。
* 特殊代码采用反射获取，反射所需要字符串（类、方法等）采用先加密（通过这样IDEA就无法找到相关引用类。）

　　**2）停止服务方法**

* SpringBoot的停止方法，
* System.exit（System.exit 这种太张扬，建议通过反射直接调用 native 方法。）
* 使用Runtime.exce 来执行kill 命令
* 采用C语言来停止线程（JNI）

　　**3）二次保护**

* 对需要保护的类进行签名，二次验证相关代码有没有别篡改。如果有篡改就直接退出程序。

> 其实上面的方案漏洞也好多，只要知道有一定的知识和相关调试能力，基本可以找到。对于经验不多的程序猿还是有一定的阻挡。
>
